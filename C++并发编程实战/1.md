# C++并发编程实战

## 1 简介

+ 为什么使用并发?  
分离关注点、性能提升  

+ 分离关注点：归类相关代码，隔离无关代码，使程序更易于理解和测试，因此所含缺陷很可能更少（划分业务），例如一个线程负责UI，一个线程负责数据处理。  
为了实现这种目的，线程的实际数量便与CPU既有的内核数量无关，因为用线程分离关注点的依据是设计理念，不以增加运算吞吐量为目的。

+ 性能提升：任务并行（单一任务分解成多个部分）、数据并行（线程对数据不同部分采取同样操作）

+ 每个线程拥有专有的内存区域：栈和堆数据段

## 2 线程管控

+ 调用构造函数的语法有可能与函数声明相同。遇到这种情况，编译器就会将其解释成函数声明，而不是定义对象
+ `std::thread` : 启动线程，接受所有可调用对象（函数指针、函数对象、lambda表达式  
+ `join()` 等待线程结束，只要调用了join()，隶属于该线程的任何存储空间即会因此清除，std::thread对象遂不再关联到已结束的线程。
+ `detach()` 不等待线程结束，在thread对象析构后，线程仍然继续执行
+ 在`std::thread`对象销毁前，必须调用`join()` or `detach()`
+ 异常发生时，利用RAII保证`join()`被正确调用

```C++
class thread_guard
{
    ...
    explicit thread_guard(std::thread& _t) : t(_t) {}

    ~thread_guard()
    {
        if (t.joinable())
        {
            t.join();
        }
    }
}
```

+ 传递参数：只需要向thread的构造函数中传入参数即可 `thread(func, arg1, arg2)`
+ 参数会按照默认方式复制到线程内部的存储空间，然后这些副本以右值的形式传递给新线程上的函数
+ 如果想要给函数传入引用，则需要给参数加上`std::ref()`包装`std::thread t(func, std::ref(arg));`
